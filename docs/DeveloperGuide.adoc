= AMR-ROS2 - Developer Guide
:site-section: DeveloperGuide
:toc:
:toclevels: 3
:toc-title: Table of Contents
:toc-placement: preamble
:icons: font
:sectnums:
:imagesDir: dg-images
:librariesDir: ../libraries
:stylesDir: stylesheets
:xrefstyle: full
:experimental:
:linkattrs:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]

:url-repo: https://github.com/zach-goh/OmronRepos/tree/master
:url-ug: https://github.com/zach-goh/OmronRepos/blob/master/docs/UserGuide.adoc

Last updated: `22 June 2021` By: `Guan Yew`

== Authors

* Xavier, Lee Kok Teng (link:https://github.com/lekoook[lekoook])
* Tan Guan Yew (link:https://github.com/guanyewtan[guanyewtan])

== Getting Started
[[prerequisites]]
=== Prerequisites

. **Ubuntu 20.04 LTS (Focal Fossa)**
+
See link:https://ubuntu.com/download/desktop[Ubuntu] webpage for installation instructions (version 20.04 release).
+
These packages were tested using Ubuntu Linux OS. Although ROS 2 is officially supported on multiple platforms including Windows OS (experimental), *Ubuntu Linux OS is preferred* since there is greater support for packages on Ubuntu platform. (These packages have not been tested on Windows OS)
+
*Virtual Machines:*
+
This AMR package can also be used on a virtual machine running Ubuntu 20.04. Ensure that the virtual machine is able to communicate with the AMR via ethernet cable, and network configuration has been done according to <<Set Up User Ethernet>>. 
+
The virtual machine tested is Oracle VM VirtualBox. Ensure that the network adapter has been set as "Bridged Adapter".

. **Robot Operating System 2 (ROS 2) Foxy Fitzroy Release**
+
Download and installation instructions can be found link:https://docs.ros.org/en/foxy/Installation/Linux-Install-Debians.html[here].
+
[NOTE]
Installing via the Ubuntu terminal and debian packages is the most convenient way to install ROS 2.
+
__Omron_TM_ROS2__ is currently supported on ROS 2 Foxy only.
+
This guide assumes you know the basics of using the ROS 2 environment. If you are new to ROS 2, please follow their series of link:https://docs.ros.org/en/foxy/Tutorials.html[tutorials] to get started with using ROS 2.
+
You will need to complete at least the `Beginner Level` tutorials. 

. **'selector2' Python2 module**
+
__LD-ROS__ uses Python low-level socket to communicate with the AMR. __selector2__ is used to assist in managing the reading/writing process through these sockets.
+
See link:https://pypi.org/project/selectors2/[selectors2].

. **Telnet**
+
Telnet application. This is only used for directly communicating with AMR's ARCL interface via a command line interface.

. **MobilePlanner 5.1.8 / ARAM**
+
The AMR set up instructions found here assumes you are using `MobilePlanner 5.1.8` to configure your AMR. For maximum compatibility, try to use this version of MobilePlanner.

=== Hardware Requirements
This package assumes a specific hardware configuration in order to work correctly.

. LD-60
+
This will be the AMR robot you will be controlling via this package.

. Host machine
+
This is a machine that communicates with the AMR, either via ethernet or wireless connection using the ARCL interface. In our use case, we use the Intel NUC8i5BEH mini PC to run ROS and communicate with the AMR via ethernet connection.

. User remote machines running ROS nodes.
+
This can be a single or multiple machines that is used to run ROS nodes that communicates with the host machine. This can either be connected to the host machine via wired or wireless connection. Although a wireless connection will be preferred for user mobility and convenience.

==== Communications Overview

The diagram below gives an overview of how the communications will be configured:

.Overview of communication
image::comms_overview.png[]

==== Hardware Wiring
The diagram below gives an overview of how the various machines needs to be wired with the AMR.

.Machines Wiring Diagram
image::wiring_diagram.png[]

The buck converter (or any other stepdown/buck converter you will use) steps the 24V-26V voltage provided by the AMR's User Power port down to a 12V-19V voltage range. The host machine used in this package is `Intel NUC8i5BEH` which accepts a 12V-19V range as input. If you use any other host machines, you will need to ensure the voltage  is stepped down or up from the AMR User Power port.

For information on what pins on AMR User Power port can be used, please see your AMR's User Manual to understand which pins to use as it may differ.

=== Set Up AMR
In order to use this package, your AMR must be configured correctly to communicate with the host machine running this ROS package. This configuration will be done via `MobilePlanner` hence, this guide assumes you have basic knowledge on using the `MobilePlanner` software.

==== Set Up User Ethernet
For reliable communication with the AMR, the user ethernet port is preferred. Hence, the user ethernet port along with it's IP needs to be configured via `SetNetGo`. You can find instructions on using `SetNetGo` in LD's User Manual or MobilePlanner User Manual.

In short, you need to configure the LD's user ethernet port to use `192.168.1.1` as it's address. This address is set in the launch file of the om_aiv_util directory to be used as the remote socket address. If you decide to use another address, you will need to change those ROS params.

Additionally, the host machine should be configured with the `192.168.1.50` address since this is also set in the ROS params in this package. If you decide to use another address, you will need to change those ROS params as well.

==== Set Up ARCL
The primary communication interface between the AMR and host machine is the `ARCL` interface. `ARCL` which stands for 'Advanced Robotics Command Language' is a communication interface that allows operators to control the AMR through a network connection. See the ARCL Reference Manual to understand it's usage.

The LD's ARCL configuration parameters must be set correctly for this package to work. First, connect to LD with `MobilePlanner` and open up the configuration page for your LD.

Within the `Robot Interface` tab, under the `ARCL server setup` section, ensure the following is set as such:

* `OpenTextServer`: `True`
+
This will enable ARCL. **Setting to 'True' is important and required.**
* `PortNumber`: `7171`
+ 
This is the port number that remote clients (like this ROS package) needs to connect to for ARCL. Default is `7171`. The ROS params is set to use this port. If you change this port here, you will need to change those ROS params as well.
* `Password`: `omron`
+
This is the password for ARCL server. **This is required.** The ROS parameter for this password in this package is set to `omron`. If you set this to something else other than `omron` in this field, you will need to change those ROS params as well.

.Example for `ARCL server setup`
image::arcl_server_setup.png[]

Within the `Robot Interface` tab, under the `Outgoing ARCL connection setup` section, ensure the following is set as such:

* `OutgoingHostname`: `192.168.1.50`
+
This is the address of your host machine. If you have set up your host machine to have a different address, this field must reflect that.
* `OutgoingPort`: `7179`
+
This is the port used in LD for ARCL communication. Default is `7179`.
* `SendStatusInterval`: `0`
+
This is the frequency of sending ARCL single line status command. We are the multiple lines status command and not this single line. So set this to `0`.
* `OutgoingSocketTimeoutInMins`: `-1.0`
+
This value indicates the duration in minutes before LD closes a ARCL connection when no data is received. Since we may not send data to ARCL all the time and we do not want the connection to close prematurely, set this to `-1.0` which keeps the connection open indefinitely until we close it.
* `RequireConnectionToPathPlan`: `True`
+
Setting this 'True' incates that an ARCL connection is required for the robot to drive autonomously. For extra safety, this is set to 'True' so in the case that a connection between host machine and LD it lost, it would stop driving autonomously.

.Example for `Outgoing ARCL connection setup`
image::outgoing_arcl_connection_setup.png[]

[[outgoing-arcl]]
Within the `Robot Interface` tab, under the `Outgoing ARCL commands` section, ensure the following is set as such:

* `OutgoingCommands1`: `Status`
+
This will get LD to send out the `Status` ARCL command repeatedly on it's own.
* `OutgoingCommands1Seconds`: `0.1`
+
This is the interval for `OutgoingCommands1` configuration.
* `OutgoingCommands2`: `RangeDeviceGetCurrent Laser_1`
+
This will get LD to send out the XY coordinates from it's main LIDAR scan repeatedly on it's own.
* `OutgoingCommands2Seconds`: `0.5`
+
This is the interval for `OutgoingCommands2` configuration.
* `OutgoingCommands3`: `GetGoals | Odometer | ApplicationFaultQuery`
+
This will get LD to send out the `GetGoals`, `Odometer` and `ApplicationFaultQuery` ARCL command repeatedly on it's own.
* `OutgoingCommands3Seconds`: `0.6`
+
This is the interval for `OutgoingCommands3` configuration.

The above interval values tested to be working. You can modify them if you find a need to (ie. faster laser scan updates).

.Example for `Outgoing ARCL commands`
image::outgoing_arcl_commands.png[]

[[set-up-host-remote-machine]]
=== Set Up Host/Remote Machine
The host machine is used to communicate with the AMR via the ARCL interface in order to retrieve vital information about the AMR that is used for this package to work.

In our use case, we use the Intel NUC8i5BEH mini PC as host machine connected to AMR's user ethernet port. Make sure your host machine meets the requirements in <<prerequisites>>.

As for remote machine(s), you can use your personal computer to run ROS nodes. Make sure your machine meets the requirements in <<prerequisites>>.

==== IP Address
Since we have set the `OutgoingHostname` to `192.168.1.50`, you need to set the ethernet network interface of your host machine to have an address of `192.168.1.50` as well. Look online on how to do this for Ubuntu.

==== ROS2 Across Multiple Machines
In order to run ROS2 on mulitple machines, you need to configure your host machine as well as your user remote machine(s) to talk to each other correctly.

Ensure that both the remote machine and host machine are on the same subnet and are discoverable to each other.

Also ensure that the ROS_DOMAIN_ID of both devices are the same.

To verify success, run the steps in the next few sections. The remote machine should be able to run the visualisation packages correctly.

==== Host Machine ROS Package Set Up
Once you have your network set up correctly, you need to set up our ROS package to work correctly in your host machine.

First, make sure you have installed ROS as described in <<prerequisites>>.

. Clone this repository to a directory of your choice with: 
+
....
cd /to/desired/path
git clone https://github.com/zach-goh/Omron_AMR_ROS2
....
. Navigate to that directory with:
+
....
cd Omron_AMR_ROS2
....
. Build this package with:
+
....
colcon build
....
+
Depending on your machine, this can take a while to build.
. After it has built successfully, ensure you source this workspace with:
+
....
source install/setup.bash
....
. Run the `om_aiv_util` package with:
+
....
ros2 launch om_aiv_util 1robot.launch
....
+
This will launch the core nodes that communicates this host machine with AMR via the ARCL interface.

[NOTE]
You may notice a mismatch of map and laser scans. In this case, you need to make sure the local copy of the map file in the host machine is the same as the one used internally by AMR. To understand this, see <<map-loading-reading>>

=== Intel NUC8i5BEH Host Machine
As mentioned in this guide, we use `Intel NUC8i5BEH` mini PC as our host machine. This machine has met the requirements in <<prerequisites>> and has it's ROS set up to work with multiple machines as described in <<set-up-host-remote-machine>>.

Additionally, the machine has been configured to run this package automatically when it has booted into Ubuntu. This allows us to run ROS nodes on our own remote machines with this host machine. The idea is that we do not need to fiddle with the host machine each time we want to use ROS with our AMR. Press the power button on `Intel NUC8i5BEH`, waits for a minute or so to boot, then run ROS nodes on our remote machine(s).

This is achieved with help of several external programs and bash scripts:

. Custom bash script
+
In order to help automate the running of the ROS at boot, we have written a simple bash script to do this. This bash script can be found at `~/boot.bash`. 


. `cron`
+
The custom bash script we have will automate the launching of several things for us. However, we need to get the machine to run that script at boot. To do this, we use `cron` job scheduling utility to help us. To configure, input `crontab -e` in a bash terminal. Please look online for usage of `cron`.

=== Running on Remote Machine
The instructions here assumes you have basic knowledge of using Git, Ubuntu, Bash terminal and ROS environment.

Follow these steps to run this package:

. Prepare a remote machine that meets the requirements in <<prerequisites>>. 
. Clone this repository to a directory of your choice with: 
+
....
cd /to/desired/path
git clone https://github.com/zach-goh/Omron_AMR_ROS2
....
. Navigate to that directory with:
+
....
cd Omron_AMR_ROS2
....
. Build this package with:
+
....
colcon build
....
+
Depending on your machine, this can take a while to build.
. After it has built successfully, ensure you source this workspace with:
+
....
source install/setup.bash
....
. Try running the `ld_visualisation` package with: 
+
....
ros2 launch ld_visualisation display.launch
....
. If you have set up the host machine and ROS multiple machines correctly, you should see RVIZ opened with a map along with the laser scans of your AMR.

== Software Design
[[architecture]]
=== Architecture
An overview of this package architecture is summarised in the diagram below:

.Overview of package
image::overview.png[]

External devices can communicate with the AMR via the ARCL interface. The AMR hosts an ARCL server that remote clients can communicate with. This is indicated by the blue `ARCL Server` block in the diagram.

In this case, the host machine will communicate via this ARCL interface. The host machine has three python modules, `Socket Driver`, `Socket Listener` and `Socket Taskmaster`. Each module opens a socket connection to the ARCL server. There are three ROS nodes that the host machines will run, `ARCL API Server`, `LD States Publisher` and `Action Server`. Their relationship with the python modules are illustrated in the diagram. These nodes and sockets will run on the host machine that is directly connected to the AMR. These are indicated by the red blocks in the diagram.

`ARCL API Server` and `LD States Publisher` nodes are implemented in the `om_aiv_util` package. `Action Server` node is implemented in the `om_aiv_navigation` package.

With the three ROS nodes, the host machine will provide a ROS interface to allow remote machines to retrieve information from, as well as controlling the AMR.

The remote machines are then able to leverage these nodes to communicate with the LD to retrieve information or to control it. These are indicated by the green blocks in the diagram. See <<amr-visualisation-package>> for how this can be implemented.

=== LD States Publisher
This ROS node is named `ld_states_publisher` during ROS runtime. The code can be found in `om_aiv_util/om_aiv_util/ld_states_publisher.py`.

The purpose of this node is to listen for a few standard information that is published by the ARCL server about the AMR. It then publishes these information on dedicated topics in the ROS environment.

The information is summarised below:

* `Status`: General message on robot's operations and actions.
* `StateOfCharge`: Battery percentage
* `Location`: XY coordinates of AMRv's position
* `LocalizationScore`: The health of AMR's localization accuracy.
* `Temperature`: Operation temperature of AMR.
* `ExtendedStatusForHumans`: Additional message to `Status` message

==== ARCL Commands Used
The publishing of the information above is made possible by a set of ARCL commands. These commands are automatically executed by the ARCL server during operation. This is made possible by configuring the ARCL server to do this. See <<outgoing-arcl, Section 2.3.2, â€œSet Up ARCL">> on an example of how this can be done.

The ARCL commands configured in ARCL server are:

. Status
. RangeDeviceGetCurrent
. GetGoals
. Odometer
. ApplicationFaultQuery

For information on what each of these commands do and how it works, please see the ARCL Reference Guide for detailed explanation.

[NOTE]
====
__RangeDeviceGetCurrent__ is not documented in the ARCL Reference Guide. This command outputs the laser scan data of the specified laser device. 

This command works in the following format: `RangeDeviceGetCurrent [laser-device-name]`

Where you should substitute [laser-device-name] field, including the `[]`, with the idetifying name of the laser device you want the data from. The output data are pairs of X-Y coordinates that represents the scan points in the world coordinate frame of the AMR.

So an output with 5 laser points will look like this: `X1 Y1 X2 Y2 X3 Y3 X4 Y4 X5 Y5`

For example in this package, __RangeDeviceGetCurrent Laser_1__ is used. The __Laser_1__ refers to the primary laser device used for mapping by AMR. Specifying another laser device name will show the data for that device instead (eg. Laser_2).

Use `MobilePlanner` software to see what laser devices are installed in the AMR and what their names are.
====

=== ARCL API Server
This ROS service node is named `arcl_api_server` during ROS runtime. The code can be found in `om_aiv_util/om_aiv_util/arcl_api_server.py`.

The purpose of this service node is to allow other ROS nodes to requests for information of a ARCL command and waits for the response. Essentially this allows any ROS nodes to post a ARCL command to the ARCL server and retrieves the response via this service node without having to have access to AMR directly.

This service node supports every single ARCL commands.

=== Action Server
This is a ROS action node, named `action_servers` during ROS runtime.
The code can be found in `om_aiv_navigation/om_aiv_navigation/action_servers.py`.

The purpose of this action node is similar to `ARCL API Server`. However, the key difference here is that is supports the publishing of feedback during the execution of a ARCL command. This is useful in instances where you need to execute a ARCL command that will last for a significant duration. 

For example, executing a `goto` ARCL command to move the AMR to a specified location. The AMR will take time to reach the goal. During this time ARCL server will continuously post messages regarding the status of this command. `Action Server` leverages this and informs callers of this action server about these status messages.

[[amr-visualisation-package]]
=== LD Visualisation Package
The `AMR Visualisation` package illustrates how a remote machine can communicate with the host machine in order to talk to the AMR to retrieve information from it or control it.

`AMR Visualisation` serves as an example as to how you can leverage the `ARCL API Server`, `LD States Publisher` and `Action Server` nodes to have basic interaction with the AMR through ROS. 

To understand how `AMR Visualisation` is structured with the entire ROS package and communicates with AMR, see <<architecture>>.

`AMR Visualisation` has three nodes, they are summarised as below:

[cols="1,1a", options="header"]
.AMR Visualisation nodes
|===
|**Node name**
|**Description**

|joints_publisher
|
This node is responsible for subscribing to the topic that publishes current location of the AMR.

Using this information, it updates the position of AMR shown on RVIZ.

|goals_marker
|
This node is responsible for subscribing to the topic that publishes the name of goals that AMR is tracking.

Using these goal names, it then requests for the coordinates of these goal points using `ARCL API Server`. These coordinates are used to visualise these goals on RVIZ.

|data_points_marker
|
This node is responsible for subscribing to the topic that publishes the coordinate of laser scan points.

Using these information, it publishes marker points on RVIZ to visualise every single scanned points.

Additionally, it also reads a `.map` created by the `MobilePlanner` software. This `.map` file contains all static map laser scan data points as well as forbidden areas. These information are all read by this node to be visualised on RVIZ. This is what makes the displaying of the map possible.

**This map file should exist on the remote machine running `AMR Visualisation`.**

See <<map-loading-reading>> to understand how to load a map onto the remote machine.

|===

== Implementation
[[map-loading-reading]]
=== Map Loading and Reading
ARCL unfortunately does not provide an interface to retrieve every single map data point as well as other map objects information from the AMR.

These information are stored in the `.map` file when you use `MobilePlanner` to scan a new map environment. The `amr_visualisation` package leverages this `.map` file to read these information display on RVIZ accordingly.

As it currently stands, a copy of the `.map` file must be retrieved from AMR via `MobilePlanner`, placed in the `amr_visualisation/map` directory and renamed to `data.map`. This `.map` file is read by `data_points_marker` node during ROS runtime to display map information on RVIZ.

Any other `.map` files in this directory will be ignored.

The name of this `.map` file can be configured as a ROS param. `AMR Visualisation` ROS params can be found in `amr_visualisation/param/vis_param.yaml`

With this implementation it means that any changes to the `.map` file on AMR can be reflected in RVIZ only by transferring the entire new `.map` file to our package and restarting the `AMR Visualisation` nodes. **This is a hard restriction from AMR software.** Additional support has to be provided by the AMR software team before a more user friendly and convenient solution can be reached.

=== Forbidden Areas Information Format
This section concerns how the forbidden areas information are stored in the `.map` file. The format is not so straightforward and hence I feel the need to include this section.

In the `.map` file, a forbidden area's information is encapsulated as a single line like so:

....
Cairn: ForbiddenArea 0 0 180.000000 "" ICON "FA1" -18561 -13725 -15055 -7739
....

* `ForbiddenArea` indicates that this line is information about a forbidden area.
* `180.000000` indicates the heading of this forbidden area.
* `FA1` indicates the name given to this forbidden area during creation.
* All other fields except for the last 4 numbers are irrelevant (As far as I know, except maybe the description field).

Now this is where it gets interesting.

Intuitively, a rectangle can be represented with two sets of XY coordinates that are two opposing corners of the said rectangle. This is also how it works in `MobilePlanner`. You give the coordinates of two opposing corners when drawing in `MobilePlanner`.

So, `-18561 -13725 -15055 -7739` must represent `X1 Y1 X2 Y2` which are the two opposing corners right?

**Wrong!**

In fact, if you compare the values here with the values you used to create the forbbiden area in `MobilePlanner`, they can be entirely different once you give a heading that is > 0.

**Turns out, the coordinates in the `.map` file are the polar coordinates transformation from the actual forbidden area.**

I'll illustrate with an example. Suppose you have an area defined with heading `90` degree and location denoted by two corners with the coordinates `6 0` and `4 2`, in the form of `X Y`. The centre of this area is thus `5 1`.

The `.map` file (transformed area) is polar coordinate transformation of the above coordinates. That means that the centre of the transformed area (radial coordinate), joined to the pole, known as pole axis is rotated by `90` degrees in the counter clockwise direction. The centre of this new transformed area is thus `-1 5`

As a result, the new coordinates of the respective corners will be `0 4` and `-2 6`. The line in `.map` file should be shown as:

....
Cairn: ForbiddenArea 0 0 90.000000 "" ICON "FA1" 0 4 -2 6
....

You may wish to experiment by drawing some simple forbidden areas on `MobilePlanner` and then drawing the coordinates on a 2D grid to understand what is going on here.

I'm not exactly sure why the `MobilePlanner` software team decided to do this way instead of __using Cartesian coordinates throughout__. It could be for calculation optimisation or to work with some other areas of their code. I hope this is the case...

== Examples
=== ROS Action: goto Goal
There are two example codes, `om_aiv_navigation/om_aiv_navigation/goto_goal.py` and `om_aiv_navigation/om_aiv_navigation/goto_goal_demo.py`.

These code files serves as an example as to how you can leverage the ROS Action servers that come with this package. The `om_aiv_util` package starts an action server, and the example code uses an action client to send a goal to the action server.

The example code simply performs the `goto` ARCL command with `Goal1` and `Goal2` as the arguments. This is get the AMR to move to `Goal1` and `Goal2` on the map, depending on which script is run.

During these operations, the feedback and result messages will be published in ROS topics.

[NOTE]
You need to have two goals named `Goal1` and `Goal2` in your AMR map for these examples to work.

. First, ensure your host machine, ROS master is up and running.
. Run `amr_visualisation` package to see the movement of your AMR. To do this:
+
....
ros2 launch amr_visualisation display.launch.py
....

. In a separate terminal with the workspace sourced, run:
+
....
ros2 run om_aiv_navigation goto_goal
....
This will move your AMR to `Goal1` on your map. Once the operation has completed, you should see  the result message in the terminal.
. Next, try moving AMR to `Goal1`, then `Goal2` with:
+
.... 
ros2 run om_aiv_navigation goto_goal_demo
.... 

=== ROS Action: Dock
There is an example code `om_aiv_navigation/om_aiv_navigation/dock.py` that demonstrates how you can add new commands using the action server by sending your own ARCL commands.

This example is the same as the one above but serves to show how new commands can easily be added.

. First, ensure your host machine, ROS master is up and running.
. Run `amr_visualisation` package to see the movement of your AMR. To do this:
+
....
ros2 launch amr_visualisation display.launch.py
....

. In a separate terminal with the workspace sourced, run:
+
....
ros2 run om_aiv_navigation dock
....
This will move your AMR to `Dock` on the map. Once in position, the docking sequence should begin as per normal.

==== Command creation
To create your own standalone commands, a few extra steps are required for the ARCL messages to be parsed correctly.

. Navigate to `src/om_aiv_navigation/om_aiv_navigation/action_server.py` then add an `elif` clause to the function `execute_callback()`.
. Choose an appropriate substring to search for that determines that the action taken is completed and search for that substring in the feedback message.
. Assign a representative message for the action to `self._result.res_msg` then `return self._result`
. Navigate to `src/om_aiv_navigation/om_aiv_navigation/[your_command].py` and add an `elif` clause to the method `feedback_callback()` to print out an appropriate feedback message by searching for a substring in the feedback message.